#### 00.4_get_OP_prescriptions.R ####
"

Download prescribing data from the Open Prescribing API. 
Sort into table which includes practice_id and ccg columns.

Info: https://openprescribing.net/api/

Requires:
  ./data/BNF_codes_measures.csv (generated by 00.3_get_BNF_info_from_OP.R)
  
Outputs
  ./data/OP_prescription_data.csv

NOTES:
- LONG RUN TIME: ~12hrs
- Final line clears all variables in the workspace except pre-exsiting variables and 'OP_prescriptions'.

"
#### Import libraries ####
library(tidyverse)
library(DBI)
library(httr)
library(jsonlite)

#### Workspace setup ####
# log existing variables
existing_vars = ls()

# get directory of current script and set it as working directory
filedir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(filedir)
getwd()

# create data folder if not yet existent
if (!dir.exists("./data")) {
  dir.create("./data")
}

#### Function definitions ####
rbind.all.columns <- function(x, y) {
  # binds all columns   
  x.diff <- setdiff(colnames(x), colnames(y))
  y.diff <- setdiff(colnames(y), colnames(x))
  
  x[, c(as.character(y.diff))] <- NA
  
  y[, c(as.character(x.diff))] <- NA
  
  return(rbind(x, y))
}

print.and.append <- function(msg, output_file_dir, append_bool){
  # Use cat both to print to console and to save to a file. Use paste() to create msg then this
  # function calls cat both with and without the append argument.
  
  cat(msg) # Print to console
  if(append_bool == TRUE){
    cat(msg, file = output_file_dir, append = TRUE)  # Append to log file  
  }else{
    cat(msg, file = output_file_dir)  # Append to log file
  }
}

# api_by_bnf JSON
api_get_prescription_data <- function(date, bnf_code, bnf_name) {
  # Call OpenPrescribing API to get full info from BNF code
  
  # Build URL for API call
  url = paste("https://openprescribing.net/api/1.0/spending_by_practice/?code=",
              bnf_code,
              "&exact=true&date=",
              date,
              "&format=json",
              sep = "")
  
  # Print message and save to log file
  print.and.append(
    paste("\nTrying BNF code: ",bnf_code," BNF name: ",bnf_name," Date: ",date,sep = ""),
    log_file_dir, 
    TRUE)
  # cat(paste("\nTrying BNF code: ",bnf_code," BNF name: ",bnf_name," Date: ",date,sep = ""), file = log_file_dir, append = TRUE) 
  
  # Count number of attempts
  attempts = 1
  
  # Call the API and act depending on return code
  while(try(api_table_JSON <- GET(url))$status != 200) { # Return code 200 = OK
    
    # Return code 429 = 'Too Many Requests'
    if(api_table_JSON$status == 429){
      print.and.append(
                paste0("\nAPI return code ", api_table_JSON$status, ": 'Too Many Requests' after ", attempts, " attempt(s). Retrying... "),
        log_file_dir, 
        TRUE)
      # cat(paste0("\nAPI return code ", api_table_JSON$status, ": 'Too Many Requests' after ", attempts, " attempt(s). Retrying... "), file = log_file_dir, append = TRUE)
      attempts = attempts + 1    
      Sys.sleep(1) # Try again in 1 s
    }
    
    # Return code 404 = 'Page Not Found'
    if(api_table_JSON$status == 404){
      api_table = fromJSON(rawToChar(api_table_JSON$content))
      print.and.append(
        paste0("\nAPI return code ", api_table_JSON$status, ": '", api_table$detail, "'. Moving to next..."),
        log_file_dir, 
        TRUE)      
      # cat(paste0("\nAPI return code ", api_table_JSON$status, ": '", api_table$detail, "'. Moving to next..."), file = log_file_dir, append = TRUE)
      return(0)}
    
    # Return code not recognized
    if(api_table_JSON$status %in% c(404, 200, 429) == FALSE){
      print.and.append(
        paste0("\nAPI return code ", api_table_JSON$status, ": No handling for this return. Moving to next..."),
        log_file_dir, 
        TRUE)           
      # cat(paste0("\nAPI return code ", api_table_JSON$status, ": No handling for this return. Moving to next..."), file = log_file_dir, append = TRUE)
      return(0)}
  }
  
  # Check if any data was received, and if so decode from JSON and sort
  api_table = fromJSON(rawToChar(api_table_JSON$content))
  if(length(api_table) > 1){
    
    # Print message
    print.and.append(
      paste0("\nAPI return code ", api_table_JSON$status, ": 'OK", api_table$detail, "'. Data received. Adding to table."),
      log_file_dir, 
      TRUE)      
    # cat(paste0("\nAPI return code ", api_table_JSON$status, ": 'OK", api_table$detail, "'. Data received. Adding to table."), file = log_file_dir, append = TRUE)
    
    # add extra rows from bnf code
    api_table$bnf_code <- bnf_code
    api_table$bnf_name <- bnf_name
    
    # rename columns for better names
    colnames(api_table)[colnames(api_table) == "row_id"] <- "practice_id"
    colnames(api_table)[colnames(api_table) == "row_name"] <- "practice_name"
    
    # reorder columns
    col_order <- c("ccg", "practice_id", "practice_name", "bnf_code", "bnf_name",
                   "items", "actual_cost", "quantity", "date", "setting")
    api_table <- api_table[, col_order]
    
    return(api_table)
  } else{
    # Print message
    print.and.append(
      paste0("\nAPI return code ", api_table_JSON$status, ": 'OK", api_table$detail, "'. Table empty. Moving to next..."),
      log_file_dir, 
      TRUE)        
    # cat(paste0("\nAPI return code ", api_table_JSON$status, ": 'OK", api_table$detail, "'. Table empty. Moving to next..."), file = log_file_dir, append = TRUE)
    return(0)
  }
}


# Write the buffer database to the main database
write.buffer.db.to.main <- function() {

  # Write message
  print.and.append(
    paste0("\n\nMoving data from buffer to main database..."),
    log_file_dir, 
    TRUE)        
  # cat(paste0("\n\nMoving data from buffer to main database..."))
    
  # Connect to the databases
  db <- DBI::dbConnect(RSQLite::SQLite(), dbname = "./data/OP_prescriptions.sqlite")
  db2 <- DBI::dbConnect(RSQLite::SQLite(), dbname = "./data/OP_prescriptions_BUFFER.sqlite")
  
  db2_table <- tbl(db2, "OP_prescriptions") %>% collect()
  
  dbWriteTable(conn = db, name = "OP_prescriptions", value = db2_table, row.names = FALSE, header = TRUE, append = TRUE)
  
  dbDisconnect(db)
  dbDisconnect(db2)
  
  rm('db', 'db2', 'db2_table')            
  
  file.remove("./data/OP_prescriptions_BUFFER.sqlite")
}


# Print row number of most recent code in database
print.row.of.last.code <- function() {
  # If code freezes and needs to be reset, you can start loop at a later BNF code.
  # Use this section to check the highest code row number in the main database.
  
  # for checking which BNF codes have already been done
  BNF_codes_measures <- read.csv("./data/BNF_codes_measures.csv")
  
  # Connect
  db <- DBI::dbConnect(RSQLite::SQLite(), dbname = "./data/OP_prescriptions.sqlite")
  
  # Extract row number numbers of codes
  db_bnfs <- 
    tbl(db, "OP_prescriptions") %>%
    select(bnf_code) %>%
    collect()
  
  db_bnfs_unique <- unique(db_bnfs$bnf_code)
  db_bnfs_match <- match(db_bnfs_unique, BNF_codes_measures$bnf_code)
  
  # Print message to user
  cat(paste("\nLast code name: ", BNF_codes_measures$bnf_name[max(db_bnfs_match)], sep=""))
  cat(paste("\nLast code row number: ", max(db_bnfs_match), sep=""))
  
  # Disconnect and tidy up
  dbDisconnect(db)
  rm('db')            
}



# Remove duplicates from the main table
remove.duplicates <- function() {
  
# for checking what the table would look like without duplicate rows
db <- DBI::dbConnect(RSQLite::SQLite(), dbname = "./data/OP_prescriptions.sqlite")

OP_prescriptions_dups <- 
  tbl(db, "OP_prescriptions") %>%
  collect()

# finally remove duplicate rows and write
OP_prescriptions <- unique(OP_prescriptions_dups)
OP_prescriptions <- OP_prescriptions %>% mutate(date = as.character(date))

dbWriteTable(conn = db, name = "OP_prescriptions", value = OP_prescriptions, row.names = FALSE, header = TRUE, overwrite = TRUE)
dbDisconnect(db)

return(OP_prescriptions)
}


#### Read in required data files and prepare variables ####
BNF_codes_measures <- read.csv("./data/BNF_codes_measures.csv")

# Create log file
log_file_dir <- paste0("./data/00.4_get_OP_prescriptions-log-", Sys.Date(), ".txt")
print.and.append(paste0("Log file for 00.4_get_OP_prescriptions.\nStarting job at ", Sys.time(), "\n", strrep("_", 50), "\n\n"),
                 log_file_dir, FALSE) # Print to console

# For checking success of calls
failed <- 0
success <- 0
total <- 0

data_to_parse = FALSE

# Dates to loop through
# years = c("2015", "2016", "2017", "2018", "2019", "2020")
years = c("2019", "2020") # No point going back further as records only go back 5 years...

months = c("01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12")

# Count the number of calls for messaging info
num_calls <- dim(BNF_codes_measures)[1] * length(months) * length(years)
num_months <- length(years)*length(months)
start_time <- Sys.time()

#### Loop through BNF codes a month at a time calling API and build table for results ####
for (row_n in 1:dim(BNF_codes_measures)[1]) {
# for (row_n in 7:dim(BNF_codes_measures)[1]) {
  
  # Get BNF code and name from BNF_codes_measures dataframe
  bnf_code <- BNF_codes_measures$bnf_code[row_n]
  bnf_name <- BNF_codes_measures$bnf_name[row_n]
  
  # Loop through years and months
  month_counter = 0
  for (year in years) {
    for (month in months) {
      month_counter = month_counter + 1
      # Construct date and continue if its before current date
      date = paste(year, month, "01", sep = "-")
      if (date < Sys.Date()) {
        # Count total and print job number
        total = total + 1

        print.and.append(paste0("\n\nCall number ", total, "/", num_calls,
                                "\nCode number ", row_n, " of ", dim(BNF_codes_measures)[1],
                                "\nMonth number ", month_counter, " of ", num_months), 
                         log_file_dir,TRUE)
        # cat(paste("\n\nCall number ", total, "/~", num_calls, sep = ""), file = log_file_dir, append = TRUE)
        # cat(paste("\nCode number ", row_n, " of ", dim(BNF_codes_measures)[1], sep = ""), file = log_file_dir, append = TRUE)
        # cat(paste("\nMonth number ", month_counter, " of ", num_months, sep = ""), file = log_file_dir, append = TRUE)
        
        # Call API to prescription info from code
        api_table = api_get_prescription_data(date, bnf_code, bnf_name)
        
        # Every 50th row, write contents of buffer db to the main database
        if(total%%50 == 0){
          if(data_to_parse){
            write.buffer.db.to.main()
            data_to_parse = FALSE
          }else{
            # Write message
            print.and.append(paste0("\n\nNo data to move from buffer this time..."),
                             log_file_dir, TRUE)
            # cat(paste0("\n\nNo data to move from buffer this time..."))
          }
        }
        
        # Check if data returned
        if(length(api_table) != 1){
          
          # Call successful
          success = success + 1
          data_to_parse = TRUE
          
          # Convert data
          api_table$date <- as.character(api_table$date)
          
          # Make or write to an SQLite database  buffer
          db <- DBI::dbConnect(RSQLite::SQLite(), dbname = "./data/OP_prescriptions_BUFFER.sqlite")
          dbWriteTable(conn = db, name = "OP_prescriptions", value = api_table, row.names = FALSE, header = TRUE, append = TRUE)
          dbDisconnect(db)
          rm('db')
          
        }else{
          # No data received, clean up and move to next
          failed = failed + 1
          rm("api_table")
          next
        }
      }
    }
  }
}

# Write any data in buffer not yet written to main table...
write.buffer.db.to.main()

#### Print script review summary, remove duplicates ####
# print success
end_time <- Sys.time()
print.and.append(
  paste0(
    "\n\nFailed: ", failed,
    "\nSuccessful: ", success,
    "\nTotal: ", total,
    "\nJob started: ", start_time, ".",
    "\nJob finished: ", end_time, ".\n"),
  log_file_dir, 
  TRUE)

# cat(paste("\n\nFailed: ", failed))
# cat(paste("\nSuccessful: ", success))
# cat(paste("\nTotal: ", total))
# cat(start_time)
# end_time <- paste("\nJob finished: ", Sys.time(), ".", sep = "")
# cat(paste("\n", end_time))

# Remove duplicate rows in main table in case code had to be restarted
OP_prescriptions <- remove.duplicates()


#### Save final table and print code summary ####

# Save prescriptions table as .csv
write_csv(OP_prescriptions, file = "./data/OP_prescriptions.csv")

# Check what codes ended up in the final table
bnfs_unique <- OP_prescriptions %>% select(bnf_code) %>% unique() %>% collect()
bnfs_list <- bnfs_unique$bnf_code
included_codes <- BNF_codes_measures %>% filter(bnf_code %in% bnfs_list)

# Print summary
for (i in 5:length(included_codes)){
  
  # For comparing input codes to results
  comparison_df <- BNF_codes_measures[i] %>% 
    group_by(BNF_codes_measures[i]) %>%
    summarise(Original = n()) %>%
    full_join(included_codes[i] %>%
                group_by(included_codes[i]) %>%
                summarise(Final = n()),
              by = colnames(BNF_codes_measures[i]))
  
  # Convert to table
  comparison_table <- knitr::kable(comparison_df, format = "simple")
  
  # Print results to console and append to log file
  print.and.append(paste0("\n\n\n"), log_file_dir, TRUE)
  cat(comparison_table, sep="\n", append = TRUE, file = log_file_dir)
  cat(comparison_table, sep="\n")
}

# remove all variables except pre-existing variables and "OP_prescriptions"
rm(list=setdiff(ls(), c(existing_vars, "OP_prescriptions")))